# ชนิดข้อมูลพื้นฐาน (Primitive Data Types)

1. **ชนิดข้อมูลตัวเลขจำนวนเต็ม**
   - `int`: จำนวนเต็มที่ขนาดขึ้นอยู่กับระบบปฏิบัติการ (32 หรือ 64 บิต)
   - `int8`, `int16`, `int32`, `int64`: จำนวนเต็มที่มีขนาดแน่นอน
   - `uint`, `uint8`, `uint16`, `uint32`, `uint64`: จำนวนเต็มไม่มีเครื่องหมาย
   - `byte`: เทียบเท่ากับ `uint8` ใช้สำหรับเก็บข้อมูลไบต์
   - `rune`: เทียบเท่ากับ `int32` ใช้เก็บรหัสตัวอักษร Unicode

2. **ชนิดข้อมูลทศนิยม**
   - `float32`: ทศนิยมความแม่นยำเดี่ยว (32 บิต)
   - `float64`: ทศนิยมความแม่นยำคู่ (64 บิต)
   - `complex64`, `complex128`: ตัวเลขเชิงซ้อน

3. **ชนิดข้อมูลอื่นๆ**
   - `bool`: ค่าความจริง (`true` หรือ `false`)
   - `string`: ลำดับของตัวอักษร Unicode

## ชนิดข้อมูลที่สร้างขึ้น (Derived/Composite Data Types)

1. **แอเรย์ (Array)**
   - คอลเลคชันข้อมูลที่มีขนาดคงที่และชนิดข้อมูลเดียวกัน
   - ตัวอย่าง: `var scores [5]int` (แอเรย์ของจำนวนเต็ม 5 ตัว)

2. **สไลซ์ (Slice)**
   - คล้ายแอเรย์แต่มีขนาดยืดหยุ่นได้
   - ตัวอย่าง: `names := []string{"Go", "Java", "Python"}` 

3. **แมพ (Map)**
   - โครงสร้างข้อมูลแบบ key-value 
   - ตัวอย่าง: `ages := map[string]int{"Alice": 25, "Bob": 30}`

4. **โครงสร้าง (Struct)**
   - ชนิดข้อมูลที่รวมตัวแปรหลายชนิดไว้ด้วยกัน
   - Struct ใน Go คล้ายกับ Interface/Type ใน TypeScript แต่ Struct ใน Go มีการจัดสรรพื้นที่หน่วยความจำจริงๆ
   - ตัวอย่าง:
     ```go
     type Person struct {
         Name string
         Age  int
     }
     ```

5. **อินเตอร์เฟส (Interface)**
   - กำหนดชุดของเมธอดที่ชนิดข้อมูลต้องมี
   - ตัวอย่าง:
     ```go
     type Writer interface {
         Write([]byte) (int, error)
     }
     ```

6. **ฟังก์ชัน (Function)**
   - ชุดคำสั่งที่สามารถเรียกใช้ซ้ำได้
   - ตัวอย่าง: `func add(a, b int) int { return a + b }`

7. **ชนิดข้อมูลช่อง (Channel)**
   - ใช้สำหรับการสื่อสารระหว่าง goroutines
   - ตัวอย่าง: `ch := make(chan int)`

## Pointers

พอยน์เตอร์เป็นตัวแปรพิเศษที่เก็บตำแหน่งหน่วยความจำของตัวแปรอื่น:

- สร้างด้วยเครื่องหมาย `*`: `var ptr *int` (พอยน์เตอร์ที่ชี้ไปยังตัวแปรชนิด int)
- รับตำแหน่งหน่วยความจำด้วยเครื่องหมาย `&`: `ptr = &someInt`
- เข้าถึงค่าที่พอยน์เตอร์ชี้ด้วยเครื่องหมาย `*`: `value := *ptr`

**ประโยชน์ของพอยน์เตอร์:**
- ช่วยประหยัดหน่วยความจำเมื่อส่งข้อมูลขนาดใหญ่ไปยังฟังก์ชัน
- อนุญาตให้ฟังก์ชันเปลี่ยนแปลงค่าของตัวแปรที่ส่งเข้าไป
- ใช้สำหรับการจัดการหน่วยความจำโดยตรง

ในภาษา Go พอยน์เตอร์มีความปลอดภัยกว่าในภาษา C เนื่องจาก Go ไม่อนุญาตให้ทำการคำนวณตำแหน่งหน่วยความจำโดยตรง ซึ่งช่วยป้องกันข้อผิดพลาดที่อาจเกิดขึ้น

## Channel

Channel เป็นหนึ่งในคุณสมบัติพิเศษที่โดดเด่นของภาษา Go ซึ่งไม่มีใน JS/TS โดยตรง Channel ใช้สำหรับการสื่อสารและส่งข้อมูลระหว่าง goroutines (คล้าย thread แต่เบากว่า) ซึ่งเป็นส่วนสำคัญของการเขียนโปรแกรมแบบ concurrent ใน Go

**ลักษณะพื้นฐานของ Channel**
```go
      // สร้าง channel ที่ส่งข้อมูลประเภท int
      ch := make(chan int)

      // ส่งค่าเข้า channel
      ch <- 42

      // รับค่าจาก channel
      value := <-ch
```

**ประเภทของ Channel**
- Unbuffered Channel: เป็น channel ที่ไม่มีบัฟเฟอร์ การส่งข้อมูลจะบล็อกจนกว่าจะมีผู้รับ
```go
   ch := make(chan int) // unbuffered channel
```
- Buffered Channel: มีพื้นที่เก็บข้อมูลชั่วคราว จะบล็อกเมื่อบัฟเฟอร์เต็ม
```go
   ch := make(chan int, 10) // buffered channel ขนาด 10
```


## Zero Value
ใน Go ถ้าตัวแปรไม่ได้ถูกกำหนดค่า จะถูกกำหนดค่าเริ่มต้นเป็น zero value ตามประเภทของมัน
Go ไม่มี null หรือ undefined เหมือน JS/TS  แต่ใช้ค่า zero value แทน

```go
   var num int       // ค่าเริ่มต้นคือ 0
	var str string    // ค่าเริ่มต้นคือ "" (empty string)
	var isValid bool  // ค่าเริ่มต้นคือ false
	var arr []int     // ค่าเริ่มต้นคือ nil (slice)
	var obj map[string]int // ค่าเริ่มต้นคือ nil (map)
```

**เช็คค่าที่ไม่มีค่า nil**
 ใช้ได้เฉพาะ ( pointer, slice, map, interface)

```go
   if mySlice == nil {
	fmt.Println("Slice ยังไม่มีค่า")
}
```